import { Button } from "../components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "../components/ui/card";
import { Badge } from "../components/ui/badge";
import { Input } from "../components/ui/input";
import {
  Sparkles,
  TrendingUp,
  Zap,
  ArrowRight,
  Users,
  Brain,
  Search,
  Calendar as CalendarIcon,
  Tag,
  Star,
  ChevronDown,
  Check,
  Bot,
  ChevronUp,
  Send,
  User,
  RefreshCw
} from "lucide-react";
import { useState, useEffect, useRef } from "react";
import { useNavigate } from "react-router-dom";
import { eventsApi, agentsApi, corporaApi } from "../lib/supabase";
import OpenAI from "openai";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "../components/ui/dialog";
import { Label } from "../components/ui/label";
import { Calendar } from "../components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "../components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../components/ui/select";
import { cn, getCategoryColor } from "../lib/utils";
import { QuestionDetailsModal } from "../components/shared/QuestionDetailsModal";
import { EditQuestionDetailsModal } from "../components/shared/EditQuestionDetailsModal";
import { RatingGauge } from "../components/shared/RatingGauge";
import { NovaProcessingModal } from "../components/shared/NovaProcessingModal";
import { ProposedEvent, Event, Agent, Corpus } from "../lib/types";
import { Checkbox } from "../components/ui/checkbox";
import { toast } from "sonner";

export function Overview() {
  const navigate = useNavigate();
  const [searchInput, setSearchInput] = useState("");
  const [questions, setQuestions] = useState<Event[]>([]);
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loading, setLoading] = useState(true);

  // Initialize OpenAI client
  const openaiClient = useRef<OpenAI | null>(null);

  useEffect(() => {
    const apiKey = import.meta.env.VITE_OPENAI_API_KEY;
    if (apiKey) {
      openaiClient.current = new OpenAI({
        apiKey: apiKey,
        dangerouslyAllowBrowser: true // Note: In production, API calls should go through a backend
      });
    } else {
      console.warn('OpenAI API key not found in environment variables');
    }
  }, []);

  // Load data from database
  useEffect(() => {
    loadData();
    loadSuggestedTweets();
  }, []);

  const loadData = async () => {
    setLoading(true);
    try {
      const [questionsData, agentsData, corporaData] = await Promise.all([
        eventsApi.getEvents(),
        agentsApi.getAgents(),
        corporaApi.getCorpora()
      ]);
      setQuestions(questionsData);
      setAgents(agentsData);
      setCorpora(corporaData || []);
      // Auto-select first corpus if available
      if (corporaData && corporaData.length > 0 && !selectedCorpusId) {
        setSelectedCorpusId(corporaData[0].id);
      }
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setLoading(false);
    }
  };

  // Load today's questions context for AI chat
  const loadTodaysContext = async (): Promise<string> => {
    try {
      // Get all questions from database
      const allQuestions = await eventsApi.getEvents();
      const allAgents = await agentsApi.getAgents();

      console.log('[Tweet Context] Total events in database:', allQuestions.length);
      console.log('[Tweet Context] All events:', allQuestions);

      // Filter events generated today by AI agents (using local timezone)
      const today = new Date();
      const todayDateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
      console.log('[Tweet Context] Today\'s date (local):', todayDateString);

      const todaysQuestions = allQuestions.filter(q => {
        if (!q.agentId) return false;
        const createdDate = new Date(q.createdAt);
        const createdDateString = `${createdDate.getFullYear()}-${String(createdDate.getMonth() + 1).padStart(2, '0')}-${String(createdDate.getDate()).padStart(2, '0')}`;
        return createdDateString === todayDateString;
      });

      console.log('[Tweet Context] Events created today with agentId:', todaysQuestions.length);
      console.log('[Tweet Context] Today\'s events:', todaysQuestions);

      // Format context: event title + agent description
      if (todaysQuestions.length === 0) {
        const emptyContext = "No events have been generated by AI agents today yet.";
        console.log('[Tweet Context] No events found, using empty context');
        setTodaysContext(emptyContext);
        return emptyContext;
      }

      const contextLines = todaysQuestions.map(q => {
        const agent = allAgents.find(a => a.id === q.agentId);
        return `- "${q.title}" (Agent: ${agent?.name || 'Unknown'} - ${agent?.description || 'No description'})`;
      });

      const contextText = `Today's AI-Generated Events (${todaysQuestions.length}):\n${contextLines.join('\n')}`;
      console.log('[Tweet Context] Final context text:', contextText);
      setTodaysContext(contextText);
      return contextText;
    } catch (error) {
      console.error('Error loading today\'s context:', error);
      setTodaysContext("");
      return "";
    }
  };

  // Load suggested tweets using OpenAI
  const loadSuggestedTweets = async () => {
    if (!openaiClient.current) {
      console.warn('OpenAI client not initialized');
      return;
    }

    setLoadingTweets(true);
    try {
      // Load today's context to provide relevant information about current content
      const currentContext = await loadTodaysContext();
      console.log('[Tweet Generation] Current context loaded:', currentContext);

      const systemPrompt = `You are a social media content creator for Intelligence Guild. Generate engaging tweets about partners, collaborations, or industry insights.

${currentContext ? `Context about today's AI-generated events:\n${currentContext}\n\n` : ''}

Your role:
1. Create tweets that reference or relate to today's generated content when available
2. Keep tweets under 280 characters
3. Make them professional yet engaging
4. Include relevant insights about partnerships or collaborations
5. Use the context above to make tweets timely and relevant`;

      console.log('[Tweet Generation] System prompt:', systemPrompt);
      console.log('[Tweet Generation] User message:', 'write me a good tweet today related to one of my partners');

      const completion = await openaiClient.current.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: 'write me a good tweet today related to one of my partners' }
        ],
        temperature: 0.8,
        max_tokens: 100,
      });

      const tweetContent = completion.choices[0]?.message?.content || "No tweet generated";
      console.log('[Tweet Generation] Generated tweet:', tweetContent);
      setSuggestedTweets([tweetContent]);
    } catch (error) {
      console.error('Error generating tweets:', error);
      setSuggestedTweets([]);
    } finally {
      setLoadingTweets(false);
    }
  };

  // Helper function to get agent name from a proposal
  const getAgentName = (proposal: ProposedEvent): string => {
    const agent = agents.find(a => a.id === proposal.agentId);
    return agent?.name || 'Unknown Agent';
  };

  // Helper function to get gradient class for suggestion cards
  const getGradientClass = (index: number): string => {
    const gradients = [
      'from-violet-500/10 to-purple-500/10',
      'from-blue-500/10 to-cyan-500/10',
      'from-pink-500/10 to-rose-500/10',
      'from-emerald-500/10 to-teal-500/10',
      'from-orange-500/10 to-amber-500/10'
    ];
    return gradients[index % gradients.length];
  };

  // Helper function to get rating badge color
  const getRatingColor = (rating: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'S'): string => {
    const colors: Record<string, string> = {
      'S': 'bg-purple-500/10 text-purple-700 border-purple-500/20',
      'A': 'bg-emerald-500/10 text-emerald-700 border-emerald-500/20',
      'B': 'bg-green-500/10 text-green-700 border-green-500/20',
      'C': 'bg-yellow-500/10 text-yellow-700 border-yellow-500/20',
      'D': 'bg-orange-500/10 text-orange-700 border-orange-500/20',
      'E': 'bg-red-500/10 text-red-700 border-red-500/20',
      'F': 'bg-rose-500/10 text-rose-700 border-rose-500/20',
    };
    return colors[rating] || colors['F'];
  };

  // Helper function to calculate average rating from multiple ratings
  const getAverageRating = (question: Event): { rating: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'S', confidence: number, sparkline: number[], categories: string[] } => {
    if (question.novaRatings && question.novaRatings.length > 0) {
      // Convert ratings to numeric values for averaging
      const ratingToNum: Record<string, number> = { 'F': 1, 'E': 2, 'D': 3, 'C': 4, 'B': 5, 'A': 6, 'S': 7 };
      const numToRating: Record<number, 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'S'> = { 1: 'F', 2: 'E', 3: 'D', 4: 'C', 5: 'B', 6: 'A', 7: 'S' };

      // Calculate average rating
      const avgRatingNum = Math.round(
        question.novaRatings.reduce((sum, r) => sum + ratingToNum[r.rating], 0) / question.novaRatings.length
      );

      // Calculate average confidence
      const confidences = question.novaRatings.filter(r => r.confidence !== undefined).map(r => r.confidence!);
      const avgConfidence = confidences.length > 0
        ? Math.round(confidences.reduce((sum, c) => sum + c, 0) / confidences.length)
        : 0;

      // Merge sparklines (take longest one or average if needed)
      const sparklines = question.novaRatings.filter(r => r.sparkline && r.sparkline.length > 0).map(r => r.sparkline!);
      const avgSparkline = sparklines.length > 0 ? sparklines[0] : [];

      // Collect all category names
      const categories = question.novaRatings.map(r => r.ratingCategory).filter(Boolean) as string[];

      return {
        rating: numToRating[avgRatingNum] || 'F',
        confidence: avgConfidence,
        sparkline: avgSparkline,
        categories
      };
    }

    // Fallback to legacy single rating
    return {
      rating: question.rating || 'F',
      confidence: question.ratingConfidence || 0,
      sparkline: question.ratingSparkline || [],
      categories: question.ratingCategory ? [question.ratingCategory] : []
    };
  };

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [questionInput, setQuestionInput] = useState("");
  const [expiryDate, setExpiryDate] = useState<Date>();
  const [settlementDate, setSettlementDate] = useState<Date>();
  const [expiryPopoverOpen, setExpiryPopoverOpen] = useState(false);
  const [settlementPopoverOpen, setSettlementPopoverOpen] = useState(false);
  const [detailsModalOpen, setDetailsModalOpen] = useState(false);
  const [selectedQuestion, setSelectedQuestion] = useState<ProposedEvent | null>(null);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [selectedEditQuestion, setSelectedEditQuestion] = useState<Event | null>(null);
  const [ratingFilter, setRatingFilter] = useState<string>("highest");
  const [novaProcessingOpen, setNovaProcessingOpen] = useState(false);
  const [novaVisibleCount, setNovaVisibleCount] = useState(8);
  const [aiVisibleCount, setAiVisibleCount] = useState(8);
  const [platformDialogOpen, setPlatformDialogOpen] = useState(false);
  const [questionToQueue, setQuestionToQueue] = useState<Event | null>(null);
  const [selectedPlatforms, setSelectedPlatforms] = useState<string[]>([]);
  const [novaCollapsed, setNovaCollapsed] = useState(true);
  const [chatOpen, setChatOpen] = useState(false);
  const [chatMessages, setChatMessages] = useState<Array<{ role: 'user' | 'assistant', content: string }>>([]);
  const [chatInput, setChatInput] = useState("");
  const [todaysContext, setTodaysContext] = useState<string>("");
  const [suggestedTweets, setSuggestedTweets] = useState<string[]>([]);
  const [loadingTweets, setLoadingTweets] = useState(false);
  const [corpora, setCorpora] = useState<Corpus[]>([]);
  const [selectedCorpusId, setSelectedCorpusId] = useState<string>("");

  const handleOpenModal = () => {
    setQuestionInput(searchInput);
    setIsModalOpen(true);
  };

  const handleOpenChat = async () => {
    // Load today's questions context
    const currentContext = await loadTodaysContext();

    if (searchInput.trim()) {
      setChatMessages([{ role: 'user', content: searchInput }]);
      setSearchInput("");
    } else if (chatMessages.length === 0 && openaiClient.current) {
      // Generate initial greeting with OpenAI using today's context
      setChatOpen(true);

      try {
        const systemPrompt = `You are an AI Content Generator helping users with Intelligence Guild.

${currentContext ? `Context about today's AI-generated events:\n${currentContext}\n\n` : ''}

Greet the user warmly and briefly explain how you can help them create content. If there are events generated today, mention them as content pieces. Keep it concise (2-3 sentences).`;

        const completion = await openaiClient.current.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: 'Hello, I need help creating content.' }
          ],
          temperature: 0.7,
          max_tokens: 150,
        });

        const greeting = completion.choices[0]?.message?.content || `Hello! I'm your AI Content Generator. I can help you create content.\n\n${currentContext}\n\nHow can I assist you today?`;
        setChatMessages([{ role: 'assistant', content: greeting }]);
      } catch (error) {
        console.error('Error generating greeting:', error);
        // Fallback greeting
        const greeting = `Hello! I'm your AI Content Generator. I can help you create content.\n\n${currentContext}\n\nHow can I assist you today?`;
        setChatMessages([{ role: 'assistant', content: greeting }]);
      }
      return;
    }
    setChatOpen(true);
  };

  const handleSendMessage = async () => {
    if (!chatInput.trim()) return;
    if (!openaiClient.current) {
      toast.error("OpenAI API not configured. Please check your API key.");
      return;
    }

    const userMessage = chatInput.trim();
    setChatInput("");
    setChatMessages(prev => [...prev, { role: 'user', content: userMessage }]);

    try {
      // Build system prompt with today's context
      const systemPrompt = `You are an AI Content Generator for Intelligence Guild, helping users create content.

${todaysContext ? `Context about today's AI-generated events:\n${todaysContext}\n\n` : ''}

Your role:
1. Help users create well-structured, engaging content
2. When asked about today's content, reference the context provided above
3. Suggest improvements to make content clear, impactful, and engaging
4. Format content as tweets unless otherwise indicated
5. Be conversational and helpful`;

      // Build messages array for OpenAI
      const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        { role: 'system', content: systemPrompt },
        ...chatMessages.map(msg => ({
          role: msg.role,
          content: msg.content
        })),
        { role: 'user', content: userMessage }
      ];

      // Call OpenAI API
      const completion = await openaiClient.current.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: messages,
        temperature: 0.7,
        max_tokens: 500,
      });

      const aiResponse = completion.choices[0]?.message?.content || "I'm sorry, I couldn't generate a response.";
      setChatMessages(prev => [...prev, { role: 'assistant', content: aiResponse }]);

    } catch (error) {
      console.error('OpenAI API error:', error);
      toast.error("Failed to get AI response. Please try again.");

      // Remove the user message if API call failed
      setChatMessages(prev => prev.slice(0, -1));

      // Restore the input
      setChatInput(userMessage);
    }
  };

  const handleUseAI = () => {
    // Mock AI rephrasing - in production this would call an LLM API
    const rephrased = `Will ${questionInput.trim() || 'this event'} happen by ${expiryDate ? expiryDate.toLocaleDateString() : 'the deadline'}?`;
    setQuestionInput(rephrased);
  };

  const handleViewDetails = (suggestion: ProposedEvent) => {
    // Convert ProposedEvent to Event for editing
    const questionForEdit: Event = {
      id: suggestion.id,
      title: suggestion.title,
      description: suggestion.description,
      state: 'published', // Overview shows live/published questions
      liveDate: suggestion.liveDate || suggestion.createdAt, // Use liveDate or fallback to createdAt
      resolutionCriteria: suggestion.resolutionCriteria,
      categories: suggestion.categories,
      agentId: suggestion.agentId,
      answerCount: 0, // Default values
      createdAt: suggestion.createdAt,
      updatedAt: new Date(),
    };

    setSelectedEditQuestion(questionForEdit);
    setEditModalOpen(true);
  };

  const handleSaveQuestion = (updatedQuestion: Event) => {
    // In a real app, this would update the backend
    // For now, we'll just show a success message
    console.log('Draft saved:', updatedQuestion);
  };

  const handleQueueLive = (updatedQuestion: Event) => {
    // Close the edit modal first
    setEditModalOpen(false);
    // Store the question and open platform selection dialog
    setQuestionToQueue(updatedQuestion);
    setSelectedPlatforms([]);
    setPlatformDialogOpen(true);
  };

  const confirmQueueLive = async () => {
    if (!questionToQueue || selectedPlatforms.length === 0) {
      toast.error("Please select at least one platform");
      return;
    }

    // Update the question state to approved and add selected platforms
    const updatedQuestion = await eventsApi.updateEvent(questionToQueue.id, {
      state: 'approved',
      pushedTo: selectedPlatforms
    });

    if (updatedQuestion) {
      toast.success(`Event approved and queued for ${selectedPlatforms.join(', ')}`);
      // Update local state
      setQuestions(questions.map(q =>
        q.id === questionToQueue.id ? updatedQuestion : q
      ));
      // Navigate to pulse page
      navigate('/pulse');
    } else {
      toast.error("Failed to queue question");
    }

    setPlatformDialogOpen(false);
    setQuestionToQueue(null);
    setSelectedPlatforms([]);
  };

  // Helper to convert Date to MySQL datetime format (YYYY-MM-DD HH:MM:SS)
  const toMySQLDateTime = (date: Date | string): string => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    const hours = String(d.getHours()).padStart(2, '0');
    const minutes = String(d.getMinutes()).padStart(2, '0');
    const seconds = String(d.getSeconds()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  };

  const handlePush = async (updatedQuestion: Event) => {
    // Close the edit modal first
    setEditModalOpen(false);

    // Check if the question has pushedTo platforms
    if (!updatedQuestion.pushedTo || updatedQuestion.pushedTo.length === 0) {
      toast.error("Event must be queued with platforms before pushing");
      return;
    }

    try {
      // Push to each selected platform
      const pushPromises = updatedQuestion.pushedTo.map(async (platform) => {
        const apiPath = platform === 'synapse'
          ? '/api/synapse/api/predictive/wager-events'
          : `/api/${platform}/api/predictive/wager-events`;

        const response = await fetch(apiPath, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            id: 0, // 0 for new question on platform
            question: updatedQuestion.title,
            extra: updatedQuestion.description || "",
            // TODO: Update API to not require answerEndAt/settlementAt fields
            liveAt: toMySQLDateTime(updatedQuestion.liveDate || new Date()),
            image: "", // Add image support later if needed
            client: platform
          })
        });

        if (!response.ok) {
          throw new Error(`Failed to push to ${platform}`);
        }

        return platform;
      });

      const pushedPlatforms = await Promise.all(pushPromises);

      // Update the question state to published in database
      const dbUpdatedQuestion = await eventsApi.updateEvent(updatedQuestion.id, {
        state: 'published',
      });

      if (dbUpdatedQuestion) {
        toast.success(`Event pushed to ${pushedPlatforms.join(', ')} and is now live!`);
        // Update local state
        setQuestions(questions.map(q =>
          q.id === updatedQuestion.id ? dbUpdatedQuestion : q
        ));
      } else {
        toast.error("Failed to update question state");
      }
    } catch (error) {
      console.error('Error pushing question:', error);
      toast.error(error instanceof Error ? error.message : "Failed to push question to platform");
    }
  };

  // Get Nova rated suggestions (pending questions with real ratings A-F, S from database)
  const ratingOrder: Record<string, number> = { 'S': 7, 'A': 6, 'B': 5, 'C': 4, 'D': 3, 'E': 2, 'F': 1 };
  const novaSuggestions = questions
    .filter(q => q.state === 'pending' && (q.rating !== undefined || (q.novaRatings && q.novaRatings.length > 0)))
    .sort((a, b) => {
      // Get the highest rating from either single rating or novaRatings array
      const getHighestRating = (q: Event) => {
        if (q.novaRatings && q.novaRatings.length > 0) {
          return Math.max(...q.novaRatings.map(r => ratingOrder[r.rating] || 1));
        }
        return ratingOrder[q.rating || 'F'] || 1;
      };

      const orderA = getHighestRating(a);
      const orderB = getHighestRating(b);
      return ratingFilter === "highest"
        ? orderB - orderA
        : orderA - orderB;
    });

  // Get all AI-generated suggestions from the last 24 hours
  const twentyFourHoursAgo = new Date();
  twentyFourHoursAgo.setHours(twentyFourHoursAgo.getHours() - 24);

  const trendingSuggestions = [...questions.filter(q => {
    if (q.state !== 'pending') return false;

    // Filter events created in the last 24 hours
    const createdDate = new Date(q.createdAt);
    return createdDate >= twentyFourHoursAgo;
  })];

  // Calculate stats from real data
  const pendingCount = questions.filter(q => q.state === 'pending').length;
  const publishedCount = questions.filter(q => q.state === 'published').length;
  const totalParticipants = questions.reduce((sum, q) => sum + (q.answerCount || 0), 0);

  const stats = [
    { label: 'Data Points', value: questions.length.toString(), icon: Zap, trend: `${publishedCount} active`, color: 'bg-metric-lime' },
    { label: 'Agents', value: agents.length.toString(), icon: Bot, trend: `${agents.filter(a => a.status === 'active').length} active`, color: 'bg-metric-peach' },
    { label: 'AI Suggestions', value: pendingCount.toString(), icon: Brain, trend: 'Ready for review', color: 'bg-metric-blue' },
  ];


  return (
    <div className="space-y-8 pb-8">
      {/* Compact Search Bar */}
      <div className="bg-gradient-to-r from-slate-50 to-slate-100 rounded-xl p-4 border border-slate-200 shadow-sm">
        <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
          <div
            className="relative flex-1 min-w-0 cursor-pointer"
            onClick={handleOpenChat}
          >
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground pointer-events-none" />
            <Input
              placeholder="Ask AI..."
              className="pl-10 bg-white border-slate-200 h-11 w-full cursor-pointer"
              value={searchInput}
              onChange={(e) => setSearchInput(e.target.value)}
              onFocus={handleOpenChat}
              readOnly
            />
          </div>
          <Button
            className="bg-gradient-to-r from-indigo-600 to-purple-600 text-white hover:from-indigo-700 hover:to-purple-700 shadow-sm sm:whitespace-nowrap"
            onClick={handleOpenChat}
          >
            <Brain className="h-4 w-4 mr-2" />
            <span className="hidden sm:inline">Chat with AI</span>
            <span className="sm:hidden">Chat</span>
          </Button>
        </div>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {stats.map((stat) => (
          <div
            key={stat.label}
            className={`${stat.color} rounded-3xl p-5 transition-transform hover:scale-[1.02] cursor-pointer`}
          >
            <div className="flex items-start justify-between mb-4">
              <h3 className="text-sm font-medium text-primary">{stat.label}</h3>
              <div className="text-primary">
                <stat.icon className="w-5 h-5" />
              </div>
            </div>
            <div className="text-[32px] font-bold text-primary leading-none mb-2">
              {stat.value}
            </div>
            <div className="text-sm text-primary">{stat.trend}</div>
          </div>
        ))}
      </div>

      {/* Suggested Tweets */}
      <div>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <Send className="h-5 w-5 text-primary" />
            <h2 className="text-2xl">Suggested Tweets</h2>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={loadSuggestedTweets}
            disabled={loadingTweets}
          >
            <RefreshCw className={`h-4 w-4 mr-2 ${loadingTweets ? 'animate-spin' : ''}`} />
            Refresh
          </Button>
        </div>

        {loadingTweets ? (
          <div className="text-center py-12">
            <Send className="h-12 w-12 text-muted-foreground mx-auto mb-4 animate-pulse" />
            <p className="text-muted-foreground">Generating tweet suggestions...</p>
          </div>
        ) : suggestedTweets.length === 0 ? (
          <Card className="p-12 text-center border-2 border-dashed">
            <Send className="h-12 w-12 text-muted-foreground mx-auto mb-4 mt-4" />
            <h3 className="text-lg font-semibold mb-2">No Tweet Suggestions Yet</h3>
            <p className="text-muted-foreground mb-4">
              Click refresh to generate AI-powered tweet suggestions
            </p>
            <Button onClick={loadSuggestedTweets}>
              <Send className="h-4 w-4 mr-2" />
              Generate Tweets
            </Button>
          </Card>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {suggestedTweets.map((tweet, index) => (
              <Card
                key={index}
                className="group hover:shadow-lg transition-all border-2 hover:border-primary/50 relative overflow-hidden"
              >
                <div className="absolute inset-0 bg-gradient-to-br from-blue-500/10 to-cyan-500/10 opacity-0 group-hover:opacity-100 transition-opacity" />

                <CardContent className="p-6 relative">
                  <div className="flex items-start gap-3 mb-4">
                    <div className="flex items-center justify-center w-10 h-10 rounded-full bg-gradient-to-r from-blue-500 to-cyan-500 text-white flex-shrink-0">
                      <Send className="h-5 w-5" />
                    </div>
                    <div className="flex-1">
                      <Badge variant="secondary" className="mb-2">
                        AI Generated
                      </Badge>
                    </div>
                  </div>

                  <p className="text-sm leading-relaxed mb-4 whitespace-pre-wrap">
                    {tweet}
                  </p>

                  <div className="flex gap-2">
                    <Button
                      size="sm"
                      variant="outline"
                      className="flex-1"
                      onClick={() => {
                        navigator.clipboard.writeText(tweet);
                        toast.success("Tweet copied to clipboard!");
                      }}
                    >
                      Copy
                    </Button>
                    <Button
                      size="sm"
                      className="flex-1 gradient-primary text-white border-0"
                      onClick={() => {
                        window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(tweet)}`, '_blank');
                      }}
                    >
                      <Send className="h-3 w-3 mr-1" />
                      Post
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        )}
      </div>

      {/* Trending AI Suggestions */}
      <div>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <TrendingUp className="h-5 w-5 text-primary" />
            <h2 className="text-2xl">AI Agent Pulse</h2>
          </div>
          <Button variant="ghost" onClick={() => navigate('/pulse')}>
            View All Suggestions
            <ArrowRight className="h-4 w-4 ml-2" />
          </Button>
        </div>

        {loading ? (
          <div className="text-center py-12">
            <Brain className="h-12 w-12 text-muted-foreground mx-auto mb-4 animate-pulse" />
            <p className="text-muted-foreground">Loading AI suggestions...</p>
          </div>
        ) : trendingSuggestions.length === 0 ? (
          <Card className="p-12 text-center border-2 border-dashed">
            <Brain className="h-12 w-12 text-muted-foreground mx-auto mb-4 mt-4" />
            <h3 className="text-lg font-semibold mb-2">No AI Suggestions Yet</h3>
            <p className="text-muted-foreground mb-4">
              Create an agent and run it to generate events
            </p>
            <Button onClick={() => navigate('/agents')}>
              Go to AI Agents
              <ArrowRight className="h-4 w-4 ml-2" />
            </Button>
          </Card>
        ) : (
          <>
          <div className="suggestions-grid">
            {trendingSuggestions.slice(0, aiVisibleCount).map((suggestion, index) => (
            <Card
              key={suggestion.id}
              className="group hover:shadow-lg transition-all cursor-pointer border-2 hover:border-primary/50 relative overflow-hidden"
              onClick={() => handleViewDetails(suggestion)}
            >
              {/* Gradient background */}
              <div className={`absolute inset-0 bg-gradient-to-br ${getGradientClass(index)} opacity-0 group-hover:opacity-100 transition-opacity`} />

              <CardHeader className="relative">
                {index === 0 && (
                  <div className="flex items-center justify-between mb-3">
                    <Badge className="bg-amber-500/10 text-amber-600 border-amber-500/20">
                      üèÜ Top Pick
                    </Badge>
                  </div>
                )}
                <CardTitle className="text-lg leading-tight group-hover:text-primary transition-colors">
                  {suggestion.title}
                </CardTitle>
              </CardHeader>
              <CardContent className="relative space-y-4">
                {/* Description - not truncated */}
                <p className="text-sm text-muted-foreground leading-relaxed">
                  {suggestion.description}
                </p>

                {/* Categories */}
                {suggestion.categories && suggestion.categories.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap">
                    <Tag className="h-3.5 w-3.5 text-muted-foreground" />
                    {suggestion.categories.map((category) => (
                      <Badge
                        key={category}
                        variant="outline"
                        className={getCategoryColor(category)}
                      >
                        {category}
                      </Badge>
                    ))}
                  </div>
                )}

                {/* Meta info */}
                <div className="flex items-center justify-between pt-2 border-t">
                  <div className="flex items-center gap-4 text-xs text-muted-foreground">
                    <div className="flex items-center gap-1">
                      <Sparkles className="h-3 w-3" />
                      <span>{getAgentName(suggestion)}</span>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
          </div>
          {aiVisibleCount < trendingSuggestions.length && (
            <div className="flex justify-center mt-6">
              <Button
                variant="outline"
                onClick={() => setAiVisibleCount(prev => prev + 8)}
                className="gap-2"
              >
                Load More
                <ChevronDown className="h-4 w-4" />
              </Button>
            </div>
          )}
          </>
        )}
      </div>

      {/* Nova Suggestions */}
      <div>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <Star className="h-5 w-5 text-amber-500" />
            <h2 className="text-2xl">‚≠ê Nova Suggestions</h2>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setNovaCollapsed(!novaCollapsed)}
              className="ml-2"
            >
              {novaCollapsed ? (
                <ChevronDown className="h-4 w-4" />
              ) : (
                <ChevronUp className="h-4 w-4" />
              )}
            </Button>
          </div>
          {!novaCollapsed && (
            <div className="flex items-center gap-3">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setNovaProcessingOpen(true)}
                className="bg-gradient-to-r from-amber-500/10 to-orange-500/10 border-amber-500/20 hover:from-amber-500/20 hover:to-orange-500/20"
              >
                <Star className="h-4 w-4 mr-2 text-amber-600" />
                Process Ratings
              </Button>
              <Select value={ratingFilter} onValueChange={setRatingFilter}>
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Sort by rating" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="highest">Highest Rated</SelectItem>
                  <SelectItem value="lowest">Lowest Rated</SelectItem>
                </SelectContent>
              </Select>
              <Button variant="ghost" onClick={() => navigate('/pulse')}>
                View All
                <ArrowRight className="h-4 w-4 ml-2" />
              </Button>
            </div>
          )}
        </div>

        {!novaCollapsed && (loading ? (
          <div className="text-center py-12">
            <Star className="h-12 w-12 text-muted-foreground mx-auto mb-4 animate-pulse" />
            <p className="text-muted-foreground">Loading Nova suggestions...</p>
          </div>
        ) : novaSuggestions.length === 0 ? (
          <Card className="p-12 text-center border-2 border-dashed">
            <Star className="h-12 w-12 text-muted-foreground mx-auto mb-4 mt-4" />
            <h3 className="text-lg font-semibold mb-2">No Nova Suggestions Yet</h3>
            <p className="text-muted-foreground mb-4">
              Generate events to see Nova ratings
            </p>
            <Button onClick={() => navigate('/pulse')}>
              Go to Pulse
              <ArrowRight className="h-4 w-4 ml-2" />
            </Button>
          </Card>
        ) : (
          <>
          <div className="suggestions-grid">
            {novaSuggestions.slice(0, novaVisibleCount).map((suggestion, index) => (
            <Card
              key={suggestion.id}
              className="group hover:shadow-lg transition-all cursor-pointer border-2 hover:border-primary/50 relative overflow-hidden"
              onClick={() => handleViewDetails(suggestion)}
            >
              {/* Gradient background */}
              <div className={`absolute inset-0 bg-gradient-to-br ${getGradientClass(index)} opacity-0 group-hover:opacity-100 transition-opacity`} />

              <CardHeader className="relative">
                <div className="flex items-start justify-between gap-4 mb-3">
                  <div className="flex-1 min-w-0">
                    <CardTitle className="text-lg leading-tight group-hover:text-primary transition-colors mb-3">
                      {suggestion.title}
                    </CardTitle>
                  </div>
                  {(suggestion.rating === 'S' || suggestion.rating === 'A' ||
                    suggestion.novaRatings?.some(r => r.rating === 'S' || r.rating === 'A')) && (
                    <Badge className="bg-amber-500/10 text-amber-600 border-amber-500/20 whitespace-nowrap">
                      ‚≠ê Top Rated
                    </Badge>
                  )}
                </div>
                {/* Display averaged rating circle and individual category rows */}
                {suggestion.novaRatings && suggestion.novaRatings.length > 0 ? (
                  <div className="space-y-4">
                    {/* Averaged Rating Circle */}
                    {(() => {
                      const avgRating = getAverageRating(suggestion);
                      return (
                        <RatingGauge
                          rating={avgRating.rating}
                          ratingCategory="Avg. Rating"
                          confidence={avgRating.confidence}
                          sparklineData={avgRating.sparkline}
                        />
                      );
                    })()}

                    {/* Individual Category Ratings (without circles) */}
                    <div className="space-y-2 pl-2 border-l-2 border-muted">
                      {suggestion.novaRatings.map((novaRating, index) => (
                        <div key={index} className="flex items-center gap-3 text-sm">
                          <span className="text-lg font-bold" style={{
                            color: (() => {
                              const configs: Record<string, string> = {
                                'S': 'rgb(168, 85, 247)', 'A': 'rgb(16, 185, 129)', 'B': 'rgb(34, 197, 94)',
                                'C': 'rgb(234, 179, 8)', 'D': 'rgb(249, 115, 22)', 'E': 'rgb(239, 68, 68)', 'F': 'rgb(244, 63, 94)'
                              };
                              return configs[novaRating.rating] || configs['F'];
                            })()
                          }}>
                            {novaRating.rating}
                          </span>
                          <span className="text-xs text-muted-foreground flex-1">
                            {novaRating.ratingCategory}
                          </span>
                          {novaRating.confidence !== undefined && novaRating.confidence !== null && (
                            <span className="text-xs text-muted-foreground">
                              {novaRating.confidence}%
                            </span>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                ) : suggestion.rating ? (
                  /* Fallback to legacy single rating */
                  <RatingGauge
                    rating={suggestion.rating}
                    ratingCategory={suggestion.ratingCategory}
                    confidence={suggestion.ratingConfidence || 0}
                    sparklineData={suggestion.ratingSparkline}
                  />
                ) : null}
              </CardHeader>
              <CardContent className="relative space-y-4">
                {/* Description */}
                <p className="text-sm text-muted-foreground leading-relaxed">
                  {suggestion.description}
                </p>

                {/* Categories */}
                {suggestion.categories && suggestion.categories.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap">
                    <Tag className="h-3.5 w-3.5 text-muted-foreground" />
                    {suggestion.categories.map((category) => (
                      <Badge
                        key={category}
                        variant="outline"
                        className={getCategoryColor(category)}
                      >
                        {category}
                      </Badge>
                    ))}
                  </div>
                )}

                {/* Meta info */}
                <div className="flex items-center justify-between pt-2 border-t">
                  <div className="flex items-center gap-4 text-xs text-muted-foreground">
                    <div className="flex items-center gap-1">
                      <Sparkles className="h-3 w-3" />
                      <span>{getAgentName(suggestion)}</span>
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
          </div>
          {novaVisibleCount < novaSuggestions.length && (
            <div className="flex justify-center mt-6">
              <Button
                variant="outline"
                onClick={() => setNovaVisibleCount(prev => prev + 8)}
                className="gap-2"
              >
                Load More
                <ChevronDown className="h-4 w-4" />
              </Button>
            </div>
          )}
          </>
        ))}
      </div>

      {/* Quick Actions */}
      <Card className="bg-gradient-to-br from-slate-50 to-slate-100 border-2">
        <CardContent className="p-6">
          <div className="flex flex-col md:flex-row items-center justify-between gap-4">
            <div>
              <h3 className="text-xl mb-1">Ready to create something new?</h3>
              <p className="text-muted-foreground">
                Use AI to generate content or create your own from scratch
              </p>
            </div>
            <div className="flex gap-3">
              <Button onClick={() => navigate('/pulse')} className="gradient-primary text-white border-0">
                <Brain className="h-4 w-4 mr-2" />
                AI Generate
              </Button>
              <Button variant="outline" onClick={() => navigate('/questions')}>
                Manual Create
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Modal for Manual Event Creation */}
      <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
        <DialogContent className="sm:max-w-[425px] max-w-[90vw]">
          <DialogHeader>
            <DialogTitle>Create Content</DialogTitle>
            <DialogDescription>
              Enter your content topic and set dates.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="question">Topic</Label>
              <Input
                id="question"
                placeholder="Enter your content topic"
                className="col-span-3"
                value={questionInput}
                onChange={(e) => setQuestionInput(e.target.value)}
              />
              <Button
                type="button"
                variant="outline"
                size="sm"
                className="bg-gradient-to-r from-indigo-600 to-purple-600 text-white hover:from-indigo-700 hover:to-purple-700 border-0"
                onClick={handleUseAI}
              >
                <Sparkles className="h-4 w-4 mr-2" />
                Use AI
              </Button>
            </div>
            <div className="space-y-2">
              <Label htmlFor="expiry-date">Publish by:</Label>
              <Popover open={expiryPopoverOpen} onOpenChange={setExpiryPopoverOpen}>
                <PopoverTrigger asChild>
                  <Button
                    variant="outline"
                    className={cn(
                      "w-full justify-start text-left",
                      !expiryDate && "text-muted-foreground"
                    )}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {expiryDate ? expiryDate.toLocaleDateString() : "Pick a date"}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0 z-[100]" align="start">
                  <Calendar
                    mode="single"
                    selected={expiryDate}
                    onSelect={(date) => {
                      setExpiryDate(date);
                      setExpiryPopoverOpen(false);
                    }}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>
            </div>
            <div className="space-y-2">
              <Label htmlFor="settlement-date">Archive by:</Label>
              <Popover open={settlementPopoverOpen} onOpenChange={setSettlementPopoverOpen}>
                <PopoverTrigger asChild>
                  <Button
                    variant="outline"
                    className={cn(
                      "w-full justify-start text-left",
                      !settlementDate && "text-muted-foreground"
                    )}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {settlementDate ? settlementDate.toLocaleDateString() : "Pick a date"}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0 z-[100]" align="start">
                  <Calendar
                    mode="single"
                    selected={settlementDate}
                    onSelect={(date) => {
                      setSettlementDate(date);
                      setSettlementPopoverOpen(false);
                    }}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>
            </div>
          </div>
          <DialogFooter>
            <Button
              type="button"
              className="bg-red-500 hover:bg-red-600 text-white"
              onClick={() => setIsModalOpen(false)}
            >
              Cancel
            </Button>
            <Button
              type="button"
              className="bg-green-500 hover:bg-green-600 text-white"
              onClick={() => {
                // Handle question creation logic here
                setIsModalOpen(false);
              }}
            >
              Create
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Event Details Modal */}
      <QuestionDetailsModal
        question={selectedQuestion}
        open={detailsModalOpen}
        onOpenChange={setDetailsModalOpen}
        onSave={(updatedQuestion: ProposedEvent) => {
          // Legacy handler if needed
        }}
        showActions={false}
      />

      {/* Edit Event Details Modal */}
      <EditQuestionDetailsModal
        open={editModalOpen}
        onOpenChange={setEditModalOpen}
        question={selectedEditQuestion}
        onSave={handleSaveQuestion}
        onQueueLive={handleQueueLive}
      />

      {/* Platform Selection Dialog */}
      <Dialog open={platformDialogOpen} onOpenChange={setPlatformDialogOpen}>
        <DialogContent className="sm:max-w-sm">
          <DialogHeader>
            <DialogTitle>Select Target Platforms</DialogTitle>
            <DialogDescription>
              Choose which platforms to push this event to
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-3">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="synapse"
                  checked={selectedPlatforms.includes("synapse")}
                  onCheckedChange={(checked) => {
                    if (checked) {
                      setSelectedPlatforms([...selectedPlatforms, "synapse"]);
                    } else {
                      setSelectedPlatforms(selectedPlatforms.filter(p => p !== "synapse"));
                    }
                  }}
                />
                <Label htmlFor="synapse" className="text-base font-normal cursor-pointer">
                  Synapse Markets
                </Label>
              </div>
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="vectra"
                  checked={selectedPlatforms.includes("vectra")}
                  onCheckedChange={(checked) => {
                    if (checked) {
                      setSelectedPlatforms([...selectedPlatforms, "vectra"]);
                    } else {
                      setSelectedPlatforms(selectedPlatforms.filter(p => p !== "vectra"));
                    }
                  }}
                />
                <Label htmlFor="vectra" className="text-base font-normal cursor-pointer">
                  Vectra Markets
                </Label>
              </div>
            </div>
            {selectedPlatforms.length === 0 && (
              <p className="text-sm text-muted-foreground">
                Please select at least one platform
              </p>
            )}
          </div>
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={() => setPlatformDialogOpen(false)}>
              Cancel
            </Button>
            <Button onClick={confirmQueueLive} disabled={selectedPlatforms.length === 0}>
              <Check className="h-4 w-4 mr-2" />
              Approve & Queue
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {/* Nova Processing Modal */}
      <NovaProcessingModal
        open={novaProcessingOpen}
        onOpenChange={setNovaProcessingOpen}
        questions={questions.filter(q => q.state === 'pending')}
        onComplete={loadData}
      />

      {/* AI Chat Window */}
      <Dialog open={chatOpen} onOpenChange={setChatOpen}>
        <DialogContent className="sm:max-w-2xl max-h-[80vh] flex flex-col p-0">
          <DialogHeader className="p-6 pb-4 border-b">
            <div className="flex items-center gap-3">
              <div className="flex items-center justify-center w-10 h-10 gradient-primary text-white rounded-lg">
                <Brain className="h-5 w-5" />
              </div>
              <div className="flex-1">
                <DialogTitle>AI Content Generator</DialogTitle>
                <DialogDescription>
                  Chat with AI to create engaging content
                </DialogDescription>
              </div>
            </div>

            {/* Knowledge Base Selector */}
            {corpora.length > 0 && (
              <div className="mt-4">
                <Label className="text-sm font-medium mb-2 block">Knowledge Base</Label>
                <Select value={selectedCorpusId} onValueChange={setSelectedCorpusId}>
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Select a knowledge base" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="none">None (General AI)</SelectItem>
                    {corpora.map((corpus) => (
                      <SelectItem key={corpus.id} value={corpus.id}>
                        {corpus.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                {selectedCorpusId && selectedCorpusId !== 'none' && (
                  <p className="text-xs text-muted-foreground mt-1">
                    Responses will use knowledge from the selected corpus
                  </p>
                )}
              </div>
            )}
          </DialogHeader>

          {/* Chat Messages */}
          <div className="flex-1 overflow-y-auto p-6 space-y-4 min-h-[400px] max-h-[50vh]">
            {chatMessages.length === 0 ? (
              <div className="text-center py-12">
                <Brain className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-lg font-semibold mb-2">Start a conversation</h3>
                <p className="text-muted-foreground">
                  Ask me to create content about anything
                </p>
              </div>
            ) : (
              chatMessages.map((message, index) => (
                <div
                  key={index}
                  className={cn(
                    "flex gap-3",
                    message.role === 'user' ? "justify-end" : "justify-start"
                  )}
                >
                  {message.role === 'assistant' && (
                    <div className="flex items-center justify-center w-8 h-8 gradient-primary text-white rounded-lg flex-shrink-0">
                      <Brain className="h-4 w-4" />
                    </div>
                  )}
                  <div
                    className={cn(
                      "rounded-lg px-4 py-3 max-w-[80%]",
                      message.role === 'user'
                        ? "bg-gradient-to-r from-indigo-600 to-purple-600"
                        : "bg-muted"
                    )}
                  >
                    <p className={cn(
                      "text-sm whitespace-pre-wrap",
                      message.role === 'user' ? "text-white" : ""
                    )}>{message.content}</p>
                  </div>
                  {message.role === 'user' && (
                    <div className="flex items-center justify-center w-8 h-8 bg-slate-200 rounded-lg flex-shrink-0">
                      <User className="h-4 w-4 text-slate-600" />
                    </div>
                  )}
                </div>
              ))
            )}
          </div>

          {/* Chat Input */}
          <div className="p-4 border-t bg-slate-50">
            <div className="flex gap-2">
              <Input
                placeholder="Type your message..."
                value={chatInput}
                onChange={(e) => setChatInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                  }
                }}
                className="flex-1 bg-white"
              />
              <Button
                onClick={handleSendMessage}
                disabled={!chatInput.trim()}
                className="gradient-primary text-white border-0"
              >
                <Send className="h-4 w-4" />
              </Button>
            </div>
            <p className="text-xs text-muted-foreground mt-2">
              Press Enter to send, Shift+Enter for new line
            </p>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
