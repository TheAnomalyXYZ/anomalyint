generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model agent_sources {
  id                  Int             @id @default(autoincrement())
  agent_id            String
  type                AgentSourceType
  config_url          String?
  config_subreddit    String?
  config_api_endpoint String?
  config_feed_url     String?
  created_at          DateTime        @default(now())
  agents              agents          @relation(fields: [agent_id], references: [id], onDelete: Cascade)
}

model agents {
  id                String          @id
  name              String
  description       String?
  categories        String[]        @default([])
  event_prompt      String
  resolution_prompt String?
  base_model        String          @default("chatgpt-4o-latest") @db.VarChar(100)
  frequency         AgentFrequency  @default(daily)
  status            AgentStatus     @default(active)
  events_created    Int             @default(0)
  last_run          DateTime?
  next_run          DateTime?
  is_template       Boolean         @default(false)
  created_at        DateTime        @default(now())
  updated_at        DateTime
  agent_sources     agent_sources[]
  events            events[]
}

model ai_resolution_proposals {
  id               String                   @id
  event_id         String                   @unique(map: "ai_resolution_proposals_question_id_key")
  resolution       Outcome
  confidence_score Decimal                  @db.Decimal(5, 4)
  reasoning        String
  evidence         Json?
  status           ResolutionProposalStatus @default(pending)
  created_by       String                   @default("AI")
  reviewed_by      String?
  reviewed_at      DateTime?
  created_at       DateTime                 @default(now())
  updated_at       DateTime
  events           events                   @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "ai_resolution_proposals_question_id_fkey")
  users            users?                   @relation(fields: [reviewed_by], references: [id])
}

model answers {
  id          String   @id
  event_id    String
  event_title String   @db.VarChar(1000)
  user_id     String
  user_name   String
  choice      Choice
  confidence  Decimal  @default(0.50) @db.Decimal(3, 2)
  channel     String   @default("web") @db.VarChar(50)
  placed_at   DateTime @default(now())
  events      events   @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "answers_question_id_fkey")
  users       users    @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model audit_events {
  id          String   @id
  timestamp   DateTime @default(now())
  actor       String
  action      String
  entity_type String   @db.VarChar(100)
  entity_id   String
  changes     Json?
  created_at  DateTime @default(now())
}

model brand_profiles {
  id                      String    @id
  name                    String
  brand_description       String?
  website                 String?
  industry                String?
  target_audience         String?
  brand_voice             String?
  key_values              String[]  @default([])
  logo_url                String?
  primary_color           String    @default("#6366f1")
  secondary_color         String    @default("#8b5cf6")
  social_links            Json      @default("{\"twitter\": \"\", \"facebook\": \"\", \"linkedin\": \"\", \"instagram\": \"\"}")
  meta_content            String[]  @default([])
  google_drive_folder_ids String[]  @default([])
  created_at              DateTime  @default(now())
  updated_at              DateTime
  corpora                 corpora[]

  @@index([created_at])
  @@index([name])
}

model categories {
  id               Int                @id @default(autoincrement())
  name             String             @unique @db.VarChar(100)
  created_at       DateTime           @default(now())
  event_categories event_categories[]
}

model chunks {
  id          String                 @id
  document_id String
  chunk_index Int
  content     String
  token_count Int?
  embedding   Unsupported("vector")?
  metadata    Json?
  created_at  DateTime               @default(now())
  documents   documents              @relation(fields: [document_id], references: [id], onDelete: Cascade)

  @@index([document_id, chunk_index])
  @@index([document_id])
}

model connector_health {
  id             String          @id
  name           String
  type           SourceType
  last_run       DateTime?
  status         ConnectorStatus @default(healthy)
  items_ingested Int             @default(0)
  failure_count  Int             @default(0)
  created_at     DateTime        @default(now())
  updated_at     DateTime
}

model corpora {
  id                     String            @id
  owner_user_id          String?
  drive_source_id        String
  name                   String            @db.VarChar(255)
  description            String?
  google_drive_folder_id String            @db.VarChar(255)
  sync_status            String            @default("idle") @db.VarChar(50)
  last_sync_at           DateTime?
  last_sync_stats        Json?
  sync_config            Json              @default("{\"recursive\": true}")
  created_at             DateTime          @default(now())
  updated_at             DateTime
  brand_profile_id       String?
  brand_profiles         brand_profiles?   @relation(fields: [brand_profile_id], references: [id])
  drive_sources          drive_sources     @relation(fields: [drive_source_id], references: [id], onDelete: Cascade)
  documents              documents[]
  ingestion_jobs         ingestion_jobs[]
  retrieval_audit        retrieval_audit[]

  @@index([brand_profile_id])
  @@index([drive_source_id])
  @@index([owner_user_id])
  @@index([sync_status])
}

model documents {
  id                   String    @id
  corpus_id            String
  google_drive_file_id String    @db.VarChar(255)
  file_name            String    @db.VarChar(500)
  file_type            String?   @db.VarChar(100)
  file_path            String?
  file_size_bytes      BigInt?
  drive_modified_at    DateTime?
  content_hash         String?   @db.VarChar(64)
  indexing_status      String    @default("pending") @db.VarChar(50)
  indexing_error       String?
  chunk_count          Int       @default(0)
  created_at           DateTime  @default(now())
  updated_at           DateTime
  chunks               chunks[]
  corpora              corpora   @relation(fields: [corpus_id], references: [id], onDelete: Cascade)

  @@unique([corpus_id, google_drive_file_id])
  @@index([corpus_id])
  @@index([drive_modified_at])
  @@index([google_drive_file_id])
  @@index([indexing_status])
}

model drive_sources {
  id                  String            @id
  owner_user_id       String?
  oauth_credential_id String
  displayName         String            @db.VarChar(255)
  googleAccountEmail  String?           @db.VarChar(255)
  last_verified_at    DateTime?
  status              String            @default("active") @db.VarChar(50)
  created_at          DateTime          @default(now())
  updated_at          DateTime
  corpora             corpora[]
  oauth_credentials   oauth_credentials @relation(fields: [oauth_credential_id], references: [id], onDelete: Cascade)

  @@index([oauth_credential_id])
  @@index([owner_user_id])
}

model event_categories {
  event_id    String
  category_id Int
  categories  categories @relation(fields: [category_id], references: [id], onDelete: Cascade, map: "question_categories_category_id_fkey")
  events      events     @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "question_categories_question_id_fkey")

  @@id([event_id, category_id])
}

model event_risk_flags {
  event_id     String
  risk_flag_id Int
  events       events     @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "question_risk_flags_question_id_fkey")
  risk_flags   risk_flags @relation(fields: [risk_flag_id], references: [id], onDelete: Cascade, map: "question_risk_flags_risk_flag_id_fkey")

  @@id([event_id, risk_flag_id])
}

model event_sources {
  id         Int      @id @default(autoincrement())
  event_id   String
  source_id  String
  created_at DateTime @default(now())
  events     events   @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "question_sources_question_id_fkey")
  sources    sources  @relation(fields: [source_id], references: [id], onDelete: Cascade, map: "question_sources_source_id_fkey")
}

model event_tags {
  event_id String
  tag_id   Int
  events   events @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "question_tags_question_id_fkey")
  tags     tags   @relation(fields: [tag_id], references: [id], onDelete: Cascade, map: "question_tags_tag_id_fkey")

  @@id([event_id, tag_id])
}

model events {
  id                      String                   @id(map: "questions_pkey")
  title                   String                   @db.VarChar(1000)
  description             String?
  state                   QuestionState            @default(draft)
  live_date               DateTime?
  answer_end_at           DateTime
  settlement_at           DateTime
  resolution_criteria     String
  topic                   String?
  agent_id                String
  pushed_to               String[]                 @default([])
  review_status           ReviewStatus?
  outcome                 Outcome?
  answer_count            Int                      @default(0)
  type                    String?                  @default("binary")
  pool_total              Decimal                  @default(0) @db.Decimal(15, 2)
  pool_yes                Decimal                  @default(0) @db.Decimal(15, 2)
  pool_no                 Decimal                  @default(0) @db.Decimal(15, 2)
  categories              String[]                 @default([])
  created_at              DateTime                 @default(now())
  updated_at              DateTime
  ai_resolution_proposals ai_resolution_proposals?
  answers                 answers[]
  event_categories        event_categories[]
  event_risk_flags        event_risk_flags[]
  event_sources           event_sources[]
  event_tags              event_tags[]
  agents                  agents                   @relation(fields: [agent_id], references: [id], onDelete: Cascade, map: "questions_agent_id_fkey")
  nova_ratings            nova_ratings[]
  outcome_evidence        outcome_evidence[]
}

model ingestion_jobs {
  id            String    @id
  corpus_id     String
  status        String    @default("pending") @db.VarChar(50)
  started_at    DateTime?
  completed_at  DateTime?
  progress      Json      @default("{\"stage\": \"initializing\", \"total\": 0, \"current\": 0}")
  stats         Json?
  error_message String?
  created_at    DateTime  @default(now())
  updated_at    DateTime
  corpora       corpora   @relation(fields: [corpus_id], references: [id], onDelete: Cascade)

  @@index([corpus_id])
  @@index([created_at])
  @@index([status])
}

model kpi_stats {
  id                Int      @id @default(autoincrement())
  label             String
  value_numeric     Decimal? @db.Decimal(15, 2)
  value_text        String?  @db.VarChar(500)
  change_percentage Decimal? @db.Decimal(5, 2)
  trend             Trend    @default(neutral)
  date_recorded     DateTime @db.Date
  created_at        DateTime @default(now())
}

model nova_ratings {
  id              Int      @id @default(autoincrement())
  event_id        String
  rating          String   @db.VarChar(1)
  rating_category String   @db.VarChar(100)
  confidence      Int?
  sparkline       Int[]    @default([])
  created_at      DateTime @default(now())
  updated_at      DateTime
  events          events   @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "nova_ratings_question_id_fkey")

  @@unique([event_id, rating_category], map: "nova_ratings_question_id_rating_category_key")
  @@index([event_id], map: "nova_ratings_question_id_idx")
  @@index([rating])
}

model oauth_credentials {
  id                      String          @id
  owner_user_id           String?
  provider                String          @db.VarChar(50)
  encrypted_access_token  String
  encrypted_refresh_token String?
  token_expires_at        DateTime?
  scope                   String[]        @default([])
  created_at              DateTime        @default(now())
  updated_at              DateTime
  drive_sources           drive_sources[]

  @@index([owner_user_id])
  @@index([provider])
}

model outcome_evidence {
  id            Int          @id @default(autoincrement())
  event_id      String
  evidence      String
  evidence_type EvidenceType @default(text)
  created_at    DateTime     @default(now())
  events        events       @relation(fields: [event_id], references: [id], onDelete: Cascade, map: "outcome_evidence_question_id_fkey")
}

model retrieval_audit {
  id         String   @id
  corpus_id  String
  query_text String
  top_k      Int      @default(5)
  results    Json?
  latency_ms Int?
  created_at DateTime @default(now())
  corpora    corpora  @relation(fields: [corpus_id], references: [id], onDelete: Cascade)

  @@index([corpus_id])
  @@index([created_at])
}

model risk_flags {
  id               Int                @id @default(autoincrement())
  name             String             @unique @db.VarChar(100)
  description      String?
  severity         RiskSeverity       @default(medium)
  created_at       DateTime           @default(now())
  event_risk_flags event_risk_flags[]
}

model sources {
  id            String          @id
  type          SourceType
  url           String
  title         String          @db.VarChar(500)
  outlet        String?
  trust_level   TrustLevel?
  fetched_at    DateTime
  content       String?
  is_pinned     Boolean         @default(false)
  created_at    DateTime        @default(now())
  event_sources event_sources[]
}

model tags {
  id         Int          @id @default(autoincrement())
  name       String       @unique @db.VarChar(100)
  created_at DateTime     @default(now())
  event_tags event_tags[]
}

model users {
  id                      String                    @id
  name                    String
  email                   String?                   @unique
  created_at              DateTime                  @default(now())
  updated_at              DateTime
  ai_resolution_proposals ai_resolution_proposals[]
  answers                 answers[]
}

enum AgentFrequency {
  daily
  on_update
  weekly
}

enum AgentSourceType {
  website
  api
  x
  reddit
  feed
}

enum AgentStatus {
  active
  paused
  error
}

enum Choice {
  YES
  NO
}

enum ClerkDocumentStatus {
  uploaded
  detecting
  completed
  error
  filling
}

enum ConnectorStatus {
  healthy
  warning
  error
}

enum EventState {
  pending
  approved
  rejected
  draft
  awaiting_review
  published
  answering_closed
  awaiting_resolution
  resolved
  invalid
  paused
}

enum EventType {
  binary
  multi_option @map("multi-option")
}

enum EvidenceType {
  url
  text
  document
}

enum Outcome {
  YES
  NO
  INVALID
}

enum QuestionState {
  pending
  approved
  rejected
  draft
  awaiting_review
  published
  answering_closed
  awaiting_resolution
  resolved
  invalid
  paused
}

enum QuestionType {
  binary
  multi_option @map("multi-option")
}

enum ResolutionProposalStatus {
  pending
  approved
  rejected
  under_review
}

enum ReviewStatus {
  pending
  approved
  revision_requested
}

enum RiskSeverity {
  low
  medium
  high
  critical
}

enum SourceType {
  twitter
  news
  meme
}

enum Trend {
  up
  down
  neutral
}

enum TrustLevel {
  high
  medium
  low
}

model clerk_documents {
  id              String               @id
  file_name       String               @db.VarChar(500)
  file_size       BigInt
  r2_url          String
  status          ClerkDocumentStatus  @default(uploaded)
  fields_detected Boolean              @default(false)
  detected_fields Json?
  line_fields     Json?
  table_fields    Json?
  text_elements   Json?
  total_pages     Int?
  filled_url      String?
  uploaded_at     DateTime             @default(now())
  processed_at    DateTime?
  created_at      DateTime             @default(now())
  updated_at      DateTime

  @@index([uploaded_at])
  @@index([status])
}
