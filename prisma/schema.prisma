// Prisma schema for Predictive Markets Dashboard
// Compatible with Supabase PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String?  @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  answers              Answer[]
  reviewedProposals    AIResolutionProposal[]

  @@map("users")
}

model Source {
  id          String      @id @default(cuid())
  type        SourceType
  url         String      @db.Text
  title       String      @db.VarChar(500)
  outlet      String?
  trustLevel  TrustLevel? @map("trust_level")
  fetchedAt   DateTime    @map("fetched_at")
  content     String?     @db.Text
  isPinned    Boolean     @default(false) @map("is_pinned")
  createdAt   DateTime    @default(now()) @map("created_at")

  questionSources QuestionSource[]

  @@map("sources")
}

model Category {
  id        Int      @id @default(autoincrement())
  name      String   @unique @db.VarChar(100)
  createdAt DateTime @default(now()) @map("created_at")

  questionCategories QuestionCategory[]

  @@map("categories")
}

model Tag {
  id        Int      @id @default(autoincrement())
  name      String   @unique @db.VarChar(100)
  createdAt DateTime @default(now()) @map("created_at")

  questionTags QuestionTag[]

  @@map("tags")
}

model RiskFlag {
  id          Int              @id @default(autoincrement())
  name        String           @unique @db.VarChar(100)
  description String?          @db.Text
  severity    RiskSeverity     @default(medium)
  createdAt   DateTime         @default(now()) @map("created_at")

  questionRiskFlags QuestionRiskFlag[]

  @@map("risk_flags")
}

model Question {
  id                 String         @id @default(cuid())
  title              String         @db.VarChar(1000)
  description        String?        @db.Text
  state              QuestionState  @default(draft)
  liveDate           DateTime?      @map("live_date")
  answerEndAt        DateTime       @map("answer_end_at")
  settlementAt       DateTime       @map("settlement_at")
  resolutionCriteria String         @map("resolution_criteria") @db.Text
  topic              String?
  agentId            String         @map("agent_id")
  pushedTo           String[]       @default([]) @map("pushed_to")
  reviewStatus       ReviewStatus?  @map("review_status")
  outcome            Outcome?
  answerCount        Int            @default(0) @map("answer_count")
  type               String?        @default("binary")
  poolTotal          Decimal        @default(0) @map("pool_total") @db.Decimal(15, 2)
  poolYes            Decimal        @default(0) @map("pool_yes") @db.Decimal(15, 2)
  poolNo             Decimal        @default(0) @map("pool_no") @db.Decimal(15, 2)
  categories         String[]       @default([])
  createdAt          DateTime       @default(now()) @map("created_at")
  updatedAt          DateTime       @updatedAt @map("updated_at")

  agent              Agent                    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  questionCategories QuestionCategory[]
  questionTags       QuestionTag[]
  questionRiskFlags  QuestionRiskFlag[]
  questionSources    QuestionSource[]
  outcomeEvidence    OutcomeEvidence[]
  answers            Answer[]
  aiResolutionProposal AIResolutionProposal?
  novaRatings        NovaRating[]

  @@map("questions")
}

model NovaRating {
  id             Int      @id @default(autoincrement())
  questionId     String   @map("question_id")
  rating         String   @db.VarChar(1)
  ratingCategory String   @map("rating_category") @db.VarChar(100)
  confidence     Int?
  sparkline      Int[]    @default([])
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([questionId, ratingCategory])
  @@map("nova_ratings")
  @@index([questionId])
  @@index([rating])
}

// ProposedQuestion model removed - consolidated into Question model with 'pending', 'approved', 'rejected' states

model AIResolutionProposal {
  id              String                   @id @default(cuid())
  questionId      String                   @unique @map("question_id")
  resolution      Outcome
  confidenceScore Decimal                  @map("confidence_score") @db.Decimal(5, 4)
  reasoning       String                   @db.Text
  evidence        Json?
  status          ResolutionProposalStatus @default(pending)
  createdBy       String                   @default("AI") @map("created_by")
  reviewedBy      String?                  @map("reviewed_by")
  reviewedAt      DateTime?                @map("reviewed_at")
  createdAt       DateTime                 @default(now()) @map("created_at")
  updatedAt       DateTime                 @updatedAt @map("updated_at")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  reviewer User?    @relation(fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@map("ai_resolution_proposals")
}

model Agent {
  id               String          @id @default(cuid())
  name             String
  description      String?         @db.Text
  categories       String[]        @default([])
  questionPrompt   String          @map("question_prompt") @db.Text
  resolutionPrompt String?         @map("resolution_prompt") @db.Text
  baseModel        String          @default("chatgpt-4o-latest") @map("base_model") @db.VarChar(100)
  frequency        AgentFrequency  @default(daily)
  status           AgentStatus     @default(active)
  questionsCreated Int             @default(0) @map("questions_created")
  lastRun          DateTime?       @map("last_run")
  nextRun          DateTime?       @map("next_run")
  isTemplate       Boolean         @default(false) @map("is_template")
  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")

  agentSources AgentSource[]
  questions    Question[]

  @@map("agents")
}

model AgentSource {
  id                Int             @id @default(autoincrement())
  agentId           String          @map("agent_id")
  type              AgentSourceType
  configUrl         String?         @map("config_url") @db.Text
  configSubreddit   String?         @map("config_subreddit")
  configApiEndpoint String?         @map("config_api_endpoint") @db.Text
  configFeedUrl     String?         @map("config_feed_url") @db.Text
  createdAt         DateTime        @default(now()) @map("created_at")

  agent Agent @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@map("agent_sources")
}

model Answer {
  id            String   @id @default(cuid())
  questionId    String   @map("question_id")
  questionTitle String   @map("question_title") @db.VarChar(1000)
  userId        String   @map("user_id")
  userName      String   @map("user_name")
  choice        Choice
  confidence    Decimal  @default(0.50) @db.Decimal(3, 2)
  channel       String   @default("web") @db.VarChar(50)
  placedAt      DateTime @default(now()) @map("placed_at")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("answers")
}

model OutcomeEvidence {
  id           Int          @id @default(autoincrement())
  questionId   String       @map("question_id")
  evidence     String       @db.Text
  evidenceType EvidenceType @default(text) @map("evidence_type")
  createdAt    DateTime     @default(now()) @map("created_at")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("outcome_evidence")
}

model ConnectorHealth {
  id            String            @id @default(cuid())
  name          String
  type          SourceType
  lastRun       DateTime?         @map("last_run")
  status        ConnectorStatus   @default(healthy)
  itemsIngested Int               @default(0) @map("items_ingested")
  failureCount  Int               @default(0) @map("failure_count")
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")

  @@map("connector_health")
}

model AuditEvent {
  id         String   @id @default(cuid())
  timestamp  DateTime @default(now())
  actor      String
  action     String
  entityType String   @map("entity_type") @db.VarChar(100)
  entityId   String   @map("entity_id")
  changes    Json?
  createdAt  DateTime @default(now()) @map("created_at")

  @@map("audit_events")
}

model KpiStat {
  id               Int      @id @default(autoincrement())
  label            String
  valueNumeric     Decimal? @map("value_numeric") @db.Decimal(15, 2)
  valueText        String?  @map("value_text") @db.VarChar(500)
  changePercentage Decimal? @map("change_percentage") @db.Decimal(5, 2)
  trend            Trend    @default(neutral)
  dateRecorded     DateTime @map("date_recorded") @db.Date
  createdAt        DateTime @default(now()) @map("created_at")

  @@map("kpi_stats")
}

// Junction tables
model QuestionCategory {
  questionId String @map("question_id")
  categoryId Int    @map("category_id")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([questionId, categoryId])
  @@map("question_categories")
}

model QuestionTag {
  questionId String @map("question_id")
  tagId      Int    @map("tag_id")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([questionId, tagId])
  @@map("question_tags")
}

model QuestionSource {
  id         Int      @id @default(autoincrement())
  questionId String   @map("question_id")
  sourceId   String   @map("source_id")
  createdAt  DateTime @default(now()) @map("created_at")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  source   Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@map("question_sources")
}

// ProposedQuestionCategory, ProposedQuestionSource, and ProposedQuestionRiskFlag models removed - use Question relations instead

model QuestionRiskFlag {
  questionId String @map("question_id")
  riskFlagId Int    @map("risk_flag_id")

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  riskFlag RiskFlag @relation(fields: [riskFlagId], references: [id], onDelete: Cascade)

  @@id([questionId, riskFlagId])
  @@map("question_risk_flags")
}

model BrandProfile {
  id                   String   @id @default(cuid())
  name                 String
  brandDescription     String?  @map("brand_description") @db.Text
  website              String?
  industry             String?
  targetAudience       String?  @map("target_audience")
  brandVoice           String?  @map("brand_voice") @db.Text
  keyValues            String[] @default([]) @map("key_values")
  logoUrl              String?  @map("logo_url")
  primaryColor         String   @default("#6366f1") @map("primary_color")
  secondaryColor       String   @default("#8b5cf6") @map("secondary_color")
  socialLinks          Json     @default("{\"twitter\": \"\", \"linkedin\": \"\", \"facebook\": \"\", \"instagram\": \"\"}") @map("social_links")
  metaContent          String[] @default([]) @map("meta_content")
  googleDriveFolderIds String[] @default([]) @map("google_drive_folder_ids")
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  corpora Corpus[]

  @@map("brand_profiles")
  @@index([name])
  @@index([createdAt])
}

// Knowledge Corpus Models for RAG

model OAuthCredential {
  id                      String   @id @default(cuid())
  ownerUserId             String?  @map("owner_user_id")
  provider                String   @db.VarChar(50)
  encryptedAccessToken    String   @map("encrypted_access_token") @db.Text
  encryptedRefreshToken   String?  @map("encrypted_refresh_token") @db.Text
  tokenExpiresAt          DateTime? @map("token_expires_at")
  scope                   String[] @default([])
  createdAt               DateTime @default(now()) @map("created_at")
  updatedAt               DateTime @updatedAt @map("updated_at")

  driveSources DriveSource[]

  @@map("oauth_credentials")
  @@index([ownerUserId])
  @@index([provider])
}

model DriveSource {
  id                  String   @id @default(cuid())
  ownerUserId         String?  @map("owner_user_id")
  oauthCredentialId   String   @map("oauth_credential_id")
  displayName         String   @db.VarChar(255)
  googleAccountEmail  String?  @db.VarChar(255)
  lastVerifiedAt      DateTime? @map("last_verified_at")
  status              String   @default("active") @db.VarChar(50)
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  oauthCredential OAuthCredential @relation(fields: [oauthCredentialId], references: [id], onDelete: Cascade)
  corpora         Corpus[]

  @@map("drive_sources")
  @@index([ownerUserId])
  @@index([oauthCredentialId])
}

model Corpus {
  id                    String   @id @default(cuid())
  ownerUserId           String?  @map("owner_user_id")
  brandProfileId        String?  @map("brand_profile_id")
  driveSourceId         String   @map("drive_source_id")
  name                  String   @db.VarChar(255)
  description           String?  @db.Text
  googleDriveFolderId   String   @map("google_drive_folder_id") @db.VarChar(255)
  syncStatus            String   @default("idle") @map("sync_status") @db.VarChar(50)
  lastSyncAt            DateTime? @map("last_sync_at")
  lastSyncStats         Json?    @map("last_sync_stats")
  syncConfig            Json     @default("{\"recursive\": true}") @map("sync_config")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  driveSource     DriveSource      @relation(fields: [driveSourceId], references: [id], onDelete: Cascade)
  brandProfile    BrandProfile?    @relation(fields: [brandProfileId], references: [id], onDelete: SetNull)
  documents       Document[]
  ingestionJobs   IngestionJob[]
  retrievalAudits RetrievalAudit[]

  @@map("corpora")
  @@index([ownerUserId])
  @@index([brandProfileId])
  @@index([driveSourceId])
  @@index([syncStatus])
}

model Document {
  id                String   @id @default(cuid())
  corpusId          String   @map("corpus_id")
  googleDriveFileId String   @map("google_drive_file_id") @db.VarChar(255)
  fileName          String   @map("file_name") @db.VarChar(500)
  fileType          String?  @map("file_type") @db.VarChar(100)
  filePath          String?  @map("file_path") @db.Text
  fileSizeBytes     BigInt?  @map("file_size_bytes")
  driveModifiedAt   DateTime? @map("drive_modified_at")
  contentHash       String?  @map("content_hash") @db.VarChar(64)
  indexingStatus    String   @default("pending") @map("indexing_status") @db.VarChar(50)
  indexingError     String?  @map("indexing_error") @db.Text
  chunkCount        Int      @default(0) @map("chunk_count")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  corpus Corpus  @relation(fields: [corpusId], references: [id], onDelete: Cascade)

  @@unique([corpusId, googleDriveFileId])
  @@map("documents")
  @@index([corpusId])
  @@index([googleDriveFileId])
  @@index([indexingStatus])
  @@index([driveModifiedAt])
}

// Note: Chunk model with vector embeddings is managed via raw SQL
// Prisma doesn't support pgvector type natively

model IngestionJob {
  id            String   @id @default(cuid())
  corpusId      String   @map("corpus_id")
  status        String   @default("pending") @db.VarChar(50)
  startedAt     DateTime? @map("started_at")
  completedAt   DateTime? @map("completed_at")
  progress      Json     @default("{\"stage\": \"initializing\", \"current\": 0, \"total\": 0}") @map("progress")
  stats         Json?    @map("stats")
  errorMessage  String?  @map("error_message") @db.Text
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  corpus Corpus @relation(fields: [corpusId], references: [id], onDelete: Cascade)

  @@map("ingestion_jobs")
  @@index([corpusId])
  @@index([status])
  @@index([createdAt])
}

model RetrievalAudit {
  id            String   @id @default(cuid())
  corpusId      String   @map("corpus_id")
  queryText     String   @map("query_text") @db.Text
  topK          Int      @default(5) @map("top_k")
  results       Json?    @map("results")
  latencyMs     Int?     @map("latency_ms")
  createdAt     DateTime @default(now()) @map("created_at")

  corpus Corpus @relation(fields: [corpusId], references: [id], onDelete: Cascade)

  @@map("retrieval_audit")
  @@index([corpusId])
  @@index([createdAt])
}

// Enums
enum SourceType {
  twitter
  news
  meme
}

enum TrustLevel {
  high
  medium
  low
}

enum QuestionState {
  pending
  approved
  rejected
  draft
  awaiting_review
  published
  answering_closed
  awaiting_resolution
  resolved
  invalid
  paused
}

enum ReviewStatus {
  pending
  approved
  revision_requested
}

enum Outcome {
  YES
  NO
  INVALID
}

enum QuestionType {
  binary
  multi_option @map("multi-option")
}

enum AgentSourceType {
  website
  api
  x
  reddit
  feed
}

enum AgentFrequency {
  daily
  on_update
  weekly
}

enum AgentStatus {
  active
  paused
  error
}

enum Choice {
  YES
  NO
}

enum EvidenceType {
  url
  text
  document
}

enum ConnectorStatus {
  healthy
  warning
  error
}

enum RiskSeverity {
  low
  medium
  high
  critical
}

enum Trend {
  up
  down
  neutral
}

enum ResolutionProposalStatus {
  pending
  approved
  rejected
  under_review
}